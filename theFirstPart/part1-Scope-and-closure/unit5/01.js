function foo() {
    var a = 2;
    function bar() {
        console.log( a ); // 2
    }
// 最准确地用来解释bar() 对 a 的引用的方法是词法作用域的查找规则，
// 而这些规则只是闭包的一部分。（但却是非常重要的一部分！）    
    bar();
}
foo();


function foo() {
    var a = 2;
    function bar() {
        console.log( a );
    }
    return bar;
}
var baz = foo();
baz(); // 2 —— 朋友，这就是闭包的效果。
// 函数 bar() 的词法作用域能够访问 foo() 的内部作用域。
// 然后我们将 bar() 函数本身当作一个值类型进行传递。
// 在这个例子中，我们将 bar 所引用的函数对象本身当作返回值

// 分析
// 在 foo() 执行后，其返回值（也就是内部的 bar() 函数）赋值给变量 baz 并调用 baz() 
// 实际上只是通过不同的标识符引用调用了内部的函数 bar() 
// bar() 显然可以被正常执行。但是在这个例子中，它在自己定义的词法作用域以外的地方执行

// 在 foo() 执行后，通常会期待 foo() 的整个内部作用域都被销毁，因为我们知道引擎有垃圾回收器用来释放不再使用的内存空间。
// 由于看上去 foo() 的内容不会再被使用，所以很自然地会考虑对其进行回收。
// 而闭包的“神奇”之处正是可以阻止这件事情的发生。事实上内部作用域依然存在，
// 因此没有被回收。谁在使用这个内部作用域？原来是 bar() 本身在使用

// 拜 bar() 所声明的位置所赐，它拥有涵盖 foo() 内部作用域的闭包，
// 使得该作用域能够一直存活，以供 bar() 在之后任何时间进行引用。
// bar() 依然持有对该作用域的引用，而这个引用就叫作闭包。

// 这个函数在定义时的词法作用域以外的地方被调用。
// 闭包使得函数可以继续访问定义时的词法作用域

function foo() {
    var a = 2;
    function baz() {
        console.log( a ); // 2
    }
    bar( baz );
}
function bar(fn) {
    fn(); // 妈妈快看呀，这就是闭包！
}
// 把内部函数 baz 传递给 bar ，当调用这个内部函数时（现在叫作 fn ），
// 它涵盖的 foo() 内部作用域的闭包就可以观察到了，因为它能够访问 a 。

var fn;
function foo() {
    var a = 2;
    function baz() {
        console.log( a );
    }
    fn = baz; // 将 baz 分配给全局变量
}
function bar() {
    fn(); // 妈妈快看呀，这就是闭包！
}
foo();
bar(); // 2
// 无论通过何种手段将内部函数传递到所在的词法作用域以外，
// 它都会持有对原始定义作用域的引用，无论在何处执行这个函数都会使用闭包