//1.2理解作用域
//编译器的处理
// 1. 遇到 var a，编译器会询问作用域是否已经有一个该名称的变量存在于同一个作用域的集合中。
// 如果是，编译器会忽略该声明，继续进行编译;
// 否则它会要求作用域在当前作 用域的集合中声明一个新的变量，并命名为a。
// 2. 接下来编译器会为引擎生成运行时所需的代码，这些代码被用来处理 a = 2 这个赋值操作。
// 引擎运行时会首先询问作用域，在当前的作用域集合中是否存在一个叫作 a 的 变量。
// 如果是，引擎就会使用这个变量;如果否，引擎会继续查找该变量(查看 1.3 节)。
// 如果引擎最终找到了 a 变量，就会将 2 赋值给它。否则引擎就会举手示意并抛出一个异常!

//左右查询
console.log(a);
// 对 a 的引用是一个 RHS 引用，因为这里 a 并没有赋予任何值
// 需要查找并取得 a 的值，这样才能将值传递给 console.log(..)

a=2;
// 这里对 a 的引用则是 LHS 引用，因为实际上我们并不关心当前的值是什么，只是想要为 =2 这个赋值操作找到一个目标

function foo(a) { 
  console.log( a ); // 2
  // 对 a 进行的 RHS 引用，并且将得到的值传给了 console.log(..)。
  // console. log(..) 本身也需要一个引用才能执行，因此会对 console 对象进行 RHS 查询，并且检查 得到的值中是否有一个叫作 log 的方法  
}
foo( 2 );
//对 foo 进行 RHS 引用，意味着“去找到 foo 的值，并把 它给我”。
// 隐式的 a=2 操作,发生在 2 被当作参数传递给 foo(..) 函数时，2 会被分配给参数 a。为了给参数 a(隐式地)分配值，需要进行一次 LHS 查询

// !!!!!!
// 编译器可以在代码生成的同时处理声明和值的定义，
// 比如在引擎执行代码时，并不会有线程专门用来将一个函数值“分配给”foo。
// 因此，将函数声明理解成前面讨论的 LHS 查询和赋值的形式并不合适。


// 小test

function foo(a) { 
  var b = a;
  return a + b; 
}
  var c = foo( 2 );
//RHS
// foo(2)  
// b=a
// return  + b
// return a + 

// a=2  x


// 如果引擎最终找到了 a 变量，就会将 2 赋值给它。否则引擎就会举手示意并抛出一个异常!
//LRS
// var c=
// a=2
// var b=
